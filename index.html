<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Cyber Rhythm Engine</title>
    <style>
        body { 
            background: radial-gradient(circle, #001233 0%, #000000 100%); 
            color: white; display: flex; flex-direction: column; align-items: center; 
            justify-content: center; height: 100vh; margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; 
        }
        #ui-container { position: absolute; top: 20px; text-align: center; z-index: 10; }
        canvas { 
            box-shadow: 0 0 50px rgba(0, 242, 255, 0.2); 
            border-left: 1px solid rgba(255,255,255,0.1);
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        button {
            padding: 10px 30px; font-size: 18px; background: transparent; 
            color: #00f2ff; border: 2px solid #00f2ff; cursor: pointer;
            transition: 0.3s; text-transform: uppercase; letter-spacing: 2px;
        }
        button:hover { background: #00f2ff; color: black; box-shadow: 0 0 20px #00f2ff; }
    </style>
</head>
<body>

<div id="ui-container">
    <h1 style="margin:0; letter-spacing: 5px; color: #00f2ff; text-shadow: 0 0 10px #00f2ff;">VELOCITY PLAY</h1>
    <p id="scoreText">SCORE: 000000</p>
    <button id="startBtn">START MISSION</button>
</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startBtn');
const scoreText = document.getElementById('scoreText');

canvas.width = 500;
canvas.height = 700;

const KEYS = ['a', 's', 'd', 'f'];
const COLORS = ['#FF007A', '#00f2ff', '#00f2ff', '#FFFFFF']; // 이미지 스타일 색상
const COLUMN_WIDTH = canvas.width / 4;
const JUDGMENT_LINE_Y = 600;
const NOTE_SPEED = 600; // 초당 600픽셀 이동

let notes = [];
let score = 0;
let startTime = 0;
let isPlaying = false;

// 샘플 노트 (MIDI 파일 받기 전 테스트용)
const sampleNotes = [
    { time: 1.0, lane: 0 }, { time: 1.5, lane: 1 }, { time: 2.0, lane: 2 }, { time: 2.5, lane: 3 },
    { time: 3.0, lane: 1 }, { time: 3.2, lane: 2 }, { time: 4.0, lane: 0 }, { time: 4.0, lane: 3 }
];

const keyState = { a: false, s: false, d: false, f: false };

window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (KEYS.includes(key)) {
        keyState[key] = true;
        checkHit(KEYS.indexOf(key));
    }
});

window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (KEYS.includes(key)) keyState[key] = false;
});

function checkHit(lane) {
    if (!isPlaying) return;
    const currentTime = (performance.now() - startTime) / 1000;
    for (let note of notes) {
        if (note.lane === lane && !note.hit) {
            const diff = Math.abs(currentTime - note.time);
            if (diff < 0.1) { // Perfect 판정
                note.hit = true;
                score += 1000;
                updateScore();
                break;
            }
        }
    }
}

function updateScore() {
    scoreText.innerText = `SCORE: ${score.toString().padStart(6, '0')}`;
}

function drawBackground() {
    // 배경 그리드 효과
    ctx.strokeStyle = 'rgba(0, 242, 255, 0.05)';
    for(let i=0; i<=4; i++) {
        ctx.beginPath();
        ctx.moveTo(i * COLUMN_WIDTH, 0);
        ctx.lineTo(i * COLUMN_WIDTH, canvas.height);
        ctx.stroke();
    }
    
    // 판정선 구역 (이미지처럼 원형 효과)
    for(let i=0; i<4; i++) {
        const x = i * COLUMN_WIDTH + COLUMN_WIDTH / 2;
        ctx.strokeStyle = keyState[KEYS[i]] ? COLORS[i] : 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, JUDGMENT_LINE_Y, 35, 0, Math.PI * 2);
        ctx.stroke();
        
        if(keyState[KEYS[i]]) {
            ctx.fillStyle = COLORS[i] + '44';
            ctx.fill();
        }
    }
}

function update() {
    if (!isPlaying) return;
    const currentTime = (performance.now() - startTime) / 1000;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBackground();

    notes.forEach(note => {
        if (!note.hit) {
            const relativeTime = note.time - currentTime;
            const y = JUDGMENT_LINE_Y - (relativeTime * NOTE_SPEED);

            if (y > -50 && y < canvas.height + 50) {
                // 네온 노트 스타일
                ctx.shadowBlur = 15;
                ctx.shadowColor = COLORS[note.lane];
                ctx.fillStyle = COLORS[note.lane];
                ctx.fillRect(note.lane * COLUMN_WIDTH + 10, y - 5, COLUMN_WIDTH - 20, 15);
                ctx.shadowBlur = 0;
            }
            
            if (y > JUDGMENT_LINE_Y + 50) note.hit = true; 
        }
    });

    requestAnimationFrame(update);
}

startBtn.addEventListener('click', () => {
    notes = sampleNotes.map(n => ({ ...n, hit: false }));
    score = 0;
    updateScore();
    startTime = performance.now();
    isPlaying = true;
    startBtn.style.display = 'none';
    update();
});
</script>
</body>
</html>
